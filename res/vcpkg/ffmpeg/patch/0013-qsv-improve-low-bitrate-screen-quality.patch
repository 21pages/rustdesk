From d3f4f5aa9d4f6f2f7d6f7c6ab4f0f3ea5fd2c6d8 Mon Sep 17 00:00:00 2001
From: rustdesk <noreply@rustdesk.com>
Date: Fri, 13 Feb 2026 15:00:00 +0800
Subject: [PATCH] avcodec/qsvenc: improve low-bitrate screen quality without frame reordering

When QSV is used for remote desktop at low bitrate, scrolling regions can
become noticeably blurry. This patch improves quality while keeping
reasonable latency by:

- using BALANCED target usage when preset is not explicitly set
- allowing a small VBR burst window instead of clamping max bitrate
- enabling quality-oriented coding options when they are left on auto
- defaulting ScenarioInfo to DISPLAY_REMOTING for low-bitrate screen cases
- keeping no-B-frame/no-reorder behavior (strict 1 in -> 1 out target)

Signed-off-by: rustdesk <noreply@rustdesk.com>
---
 libavcodec/qsvenc.c | 55 ++++++++++++++++++++++++++++++++----------
 1 file changed, 43 insertions(+), 12 deletions(-)

diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index 8c4a42e7c2..b80ebf13d6 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -792,7 +792,12 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
     }
 
     if (avctx->compression_level == FF_COMPRESSION_DEFAULT) {
-        avctx->compression_level = q->preset;
+        if (q->preset != MFX_TARGETUSAGE_UNKNOWN) {
+            avctx->compression_level = q->preset;
+        } else {
+            /* Prefer balanced quality/speed when caller does not set preset. */
+            avctx->compression_level = MFX_TARGETUSAGE_BALANCED;
+        }
     } else if (avctx->compression_level >= 0) {
         if (avctx->compression_level > MFX_TARGETUSAGE_BEST_SPEED) {
             av_log(avctx, AV_LOG_WARNING, "Invalid compression level: "
@@ -815,6 +820,6 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
     q->param.mfx.GopPicSize         = FFMAX(0, avctx->gop_size);
     q->old_gop_size                 = avctx->gop_size;
     q->param.mfx.GopRefDist         = FFMAX(-1, avctx->max_b_frames) + 1;
     q->param.mfx.GopOptFlag         = avctx->flags & AV_CODEC_FLAG_CLOSED_GOP ?
                                       MFX_GOP_CLOSED : is_strict_gop(q) ?
                                       MFX_GOP_STRICT : 0;
@@ -893,6 +905,20 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
     target_bitrate_kbps        = avctx->bit_rate / 1000;
     max_bitrate_kbps           = avctx->rc_max_rate / 1000;
     brc_param_multiplier       = (FFMAX(FFMAX3(target_bitrate_kbps, max_bitrate_kbps, buffer_size_in_kilobytes),
                                   initial_delay_in_kilobytes) + 0x10000) / 0x10000;
+
+    if ((avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_HEVC) &&
+        target_bitrate_kbps > 0 && target_bitrate_kbps <= 4000 &&
+        q->param.mfx.RateControlMethod == MFX_RATECONTROL_VBR) {
+        if (max_bitrate_kbps <= target_bitrate_kbps) {
+            max_bitrate_kbps = FFMIN(50000,
+                                     FFMAX(target_bitrate_kbps + 500,
+                                           (target_bitrate_kbps * 3) / 2));
+        }
+        if (buffer_size_in_kilobytes <= 0)
+            buffer_size_in_kilobytes = FFMAX(512, target_bitrate_kbps * 2);
+    }
+
     q->old_rc_buffer_size = avctx->rc_buffer_size;
     q->old_rc_initial_buffer_occupancy = avctx->rc_initial_buffer_occupancy;
     q->old_bit_rate = avctx->bit_rate;
@@ -1077,6 +1103,16 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
                 q->extco2.MBBRC = q->mbbrc ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
             if (q->skip_frame >= 0)
                 q->extco2.SkipFrame = q->skip_frame;
+
+            if ((avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_HEVC) &&
+                avctx->bit_rate > 0 && avctx->bit_rate <= 4000000) {
+                if (q->mbbrc < 0)
+                    q->extco2.MBBRC = MFX_CODINGOPTION_ON;
+                if (q->extbrc < 0)
+                    q->extco2.ExtBRC = MFX_CODINGOPTION_ON;
+                if (q->adaptive_i < 0)
+                    q->extco2.AdaptiveI = MFX_CODINGOPTION_ON;
+            }
 
             q->extco2.Header.BufferId = MFX_EXTBUFF_CODING_OPTION2;
             q->extco2.Header.BufferSz = sizeof(q->extco2);
@@ -1153,7 +1200,14 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
                 (q->profile == MFX_PROFILE_HEVC_REXT ||
                 q->profile == MFX_PROFILE_UNKNOWN))
                 q->extco3.TargetChromaFormatPlus1 = MFX_CHROMAFORMAT_YUV444 + 1;
-            q->extco3.ScenarioInfo = q->scenario;
+            if (q->scenario != MFX_SCENARIO_UNKNOWN) {
+                q->extco3.ScenarioInfo = q->scenario;
+            } else if ((avctx->codec_id == AV_CODEC_ID_H264 || avctx->codec_id == AV_CODEC_ID_HEVC) &&
+                       avctx->bit_rate > 0 && avctx->bit_rate <= 4000000) {
+                q->extco3.ScenarioInfo = MFX_SCENARIO_DISPLAY_REMOTING;
+            } else {
+                q->extco3.ScenarioInfo = q->scenario;
+            }
         } else if (avctx->codec_id == AV_CODEC_ID_AV1) {
             if (q->low_delay_brc >= 0)
                 q->extco3.LowDelayBRC = q->low_delay_brc ? MFX_CODINGOPTION_ON : MFX_CODINGOPTION_OFF;
-- 
2.43.0.windows.1
