diff --git a/cpp/common/util.cpp b/cpp/common/util.cpp
index 1234567..abcdefg 100644
--- a/cpp/common/util.cpp
+++ b/cpp/common/util.cpp
@@ -18,7 +18,7 @@ namespace util_encode {
 
 void set_av_codec_ctx(AVCodecContext *c, const std::string &name, int kbs,
-                      int gop, int fps) {
+                      int gop, int fps, int rc_buffer_size) {
   c->has_b_frames = 0;
   c->max_b_frames = 0;
   if (gop > 0 && gop < std::numeric_limits<int16_t>::max()) {
@@ -35,10 +35,21 @@ void set_av_codec_ctx(AVCodecContext *c, const std::string &name, int kbs,
   // https://github.com/FFmpeg/FFmpeg/blob/415f012359364a77e8394436f222b74a8641a3ee/libavcodec/encode.c#L581
   if (kbs > 0) {
     c->bit_rate = kbs * 1000;
+    
+    // Set VBV buffer size for better rate control
+    if (rc_buffer_size > 0) {
+      c->rc_buffer_size = rc_buffer_size * 1000;
+    } else if (fps > 0) {
+      // Default: single-frame VBV for low-latency streaming
+      // This prevents large bitrate spikes and provides smoother bitrate distribution
+      c->rc_buffer_size = (kbs * 1000) / fps;
+    }
+    
     if (name.find("qsv") != std::string::npos) {
       c->rc_max_rate = c->bit_rate;
       c->bit_rate--; // cbr with vbr
     }
+    // Note: rc_min_rate not set to allow VBR mode for better quality
   }
   /* frames per second */
   c->time_base = av_make_q(1, 1000);
@@ -243,6 +254,84 @@ bool set_rate_control(AVCodecContext *c, const std::string &name, int rc,
 
   return true;
 }
+
+bool set_qp_range(void *priv_data, const std::string &name, int min_qp, int max_qp) {
+  int ret = 0;
+  
+  // Setting min/max QP helps maintain consistent quality especially at lower frame rates
+  // Min QP prevents the encoder from wasting bits on imperceptible quality improvements
+  // Max QP prevents the encoder from degrading quality too much
+  
+  if (name.find("nvenc") != std::string::npos) {
+    // NVENC supports qmin/qmax for all frame types (I, P, B)
+    // Format: "qpI,qpP,qpB" but we use same value for all
+    if (min_qp >= 0) {
+      char qp_str[32];
+      snprintf(qp_str, sizeof(qp_str), "%d,%d,%d", min_qp, min_qp, min_qp);
+      if ((ret = av_opt_set(priv_data, "qmin", qp_str, 0)) < 0) {
+        LOG_WARN(std::string("nvenc set qmin failed, ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("nvenc qmin set to ") + std::to_string(min_qp));
+      }
+    }
+    if (max_qp >= 0) {
+      char qp_str[32];
+      snprintf(qp_str, sizeof(qp_str), "%d,%d,%d", max_qp, max_qp, max_qp);
+      if ((ret = av_opt_set(priv_data, "qmax", qp_str, 0)) < 0) {
+        LOG_WARN(std::string("nvenc set qmax failed, ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("nvenc qmax set to ") + std::to_string(max_qp));
+      }
+    }
+  }
+  
+  if (name.find("qsv") != std::string::npos) {
+    // Intel QSV uses qmin/qmax as integer options
+    if (min_qp >= 0) {
+      if ((ret = av_opt_set_int(priv_data, "qmin", min_qp, 0)) < 0) {
+        LOG_WARN(std::string("qsv set qmin failed, ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("qsv qmin set to ") + std::to_string(min_qp));
+      }
+    }
+    if (max_qp >= 0) {
+      if ((ret = av_opt_set_int(priv_data, "qmax", max_qp, 0)) < 0) {
+        LOG_WARN(std::string("qsv set qmax failed, ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("qsv qmax set to ") + std::to_string(max_qp));
+      }
+    }
+  }
+  
+  if (name.find("amf") != std::string::npos) {
+    // AMD AMF uses qp_min/qp_max (note: might not be supported on all versions)
+    if (min_qp >= 0) {
+      if ((ret = av_opt_set_int(priv_data, "qp_min", min_qp, 0)) < 0) {
+        LOG_WARN(std::string("amf set qp_min failed (might not be supported), ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("amf qp_min set to ") + std::to_string(min_qp));
+      }
+    }
+    if (max_qp >= 0) {
+      if ((ret = av_opt_set_int(priv_data, "qp_max", max_qp, 0)) < 0) {
+        LOG_WARN(std::string("amf set qp_max failed (might not be supported), ret = ") + av_err2str(ret));
+      } else {
+        LOG_INFO(std::string("amf qp_max set to ") + std::to_string(max_qp));
+      }
+    }
+  }
+  
+  if (name.find("vaapi") != std::string::npos) {
+    // VAAPI typically uses VBR mode with quality parameter instead of QP control
+    // QP control only works in CQP (Constant QP) mode which we don't use for streaming
+    // So we skip QP setting for VAAPI and rely on bitrate-based VBR instead
+    if (min_qp >= 0 || max_qp >= 0) {
+      LOG_INFO(std::string("vaapi: QP range not applicable in VBR mode"));
+    }
+  }
+  
+  return true;
+}
+
 bool set_gpu(void *priv_data, const std::string &name, int gpu) {
   int ret;
   if (gpu < 0)
diff --git a/cpp/common/util.h b/cpp/common/util.h
index 1234567..abcdefg 100644
--- a/cpp/common/util.h
+++ b/cpp/common/util.h
@@ -10,10 +10,11 @@
 namespace util_encode {
 
 void set_av_codec_ctx(AVCodecContext *c, const std::string &name, int kbs,
-                      int gop, int fps);
+                      int gop, int fps, int rc_buffer_size = -1);
 bool set_lantency_free(void *priv_data, const std::string &name);
 bool set_quality(void *priv_data, const std::string &name, int quality);
 bool set_rate_control(AVCodecContext *c, const std::string &name, int rc, int q);
+bool set_qp_range(void *priv_data, const std::string &name, int min_qp, int max_qp);
 bool set_gpu(void *priv_data, const std::string &name, int gpu);
 void force_hw(void *priv_data, const std::string &name);
 void set_others(void *priv_data, const std::string &name);
diff --git a/cpp/ffmpeg_ram/ffmpeg_ram_encode.cpp b/cpp/ffmpeg_ram/ffmpeg_ram_encode.cpp
index 1234567..abcdefg 100644
--- a/cpp/ffmpeg_ram/ffmpeg_ram_encode.cpp
+++ b/cpp/ffmpeg_ram/ffmpeg_ram_encode.cpp
@@ -118,12 +118,16 @@ public:
   RamEncodeCallback callback_ = NULL;
   int offset_[AV_NUM_DATA_POINTERS] = {0};
 
+  int min_qp_ = -1;
+  int max_qp_ = -1;
+  int rc_buffer_size_ = -1;
+
   AVHWDeviceType hw_device_type_ = AV_HWDEVICE_TYPE_NONE;
   AVPixelFormat hw_pixfmt_ = AV_PIX_FMT_NONE;
   AVBufferRef *hw_device_ctx_ = NULL;
   AVFrame *hw_frame_ = NULL;
 
   FFmpegRamEncoder(const char *name, const char *mc_name, int width, int height,
                    int pixfmt, int align, int fps, int gop, int rc, int quality,
-                   int kbs, int q, int thread_count, int gpu,
+                   int kbs, int q, int thread_count, int gpu, 
+                   int min_qp, int max_qp, int rc_buffer_size,
                    RamEncodeCallback callback) {
     name_ = name;
@@ -141,6 +145,9 @@ public:
     thread_count_ = thread_count;
     gpu_ = gpu;
     callback_ = callback;
+    min_qp_ = min_qp;
+    max_qp_ = max_qp;
+    rc_buffer_size_ = rc_buffer_size;
     if (name_.find("vaapi") != std::string::npos) {
       hw_device_type_ = AV_HWDEVICE_TYPE_VAAPI;
       hw_pixfmt_ = AV_PIX_FMT_VAAPI;
@@ -230,10 +237,15 @@ public:
     c_->pix_fmt =
         hw_pixfmt_ != AV_PIX_FMT_NONE ? hw_pixfmt_ : (AVPixelFormat)pixfmt_;
     c_->sw_pix_fmt = (AVPixelFormat)pixfmt_;
-    util_encode::set_av_codec_ctx(c_, name_, kbs_, gop_, fps_);
+    util_encode::set_av_codec_ctx(c_, name_, kbs_, gop_, fps_, rc_buffer_size_);
     if (!util_encode::set_lantency_free(c_->priv_data, name_)) {
       LOG_ERROR(std::string("set_lantency_free failed, name: ") + name_);
       return false;
     }
     // util_encode::set_quality(c_->priv_data, name_, quality_);
     util_encode::set_rate_control(c_, name_, rc_, q_);
+    
+    // Set QP range for better quality control, especially at low frame rates
+    if (min_qp_ >= 0 || max_qp_ >= 0) {
+      util_encode::set_qp_range(c_->priv_data, name_, min_qp_, max_qp_);
+    }
+    
     util_encode::set_gpu(c_->priv_data, name_, gpu_);
     util_encode::force_hw(c_->priv_data, name_);
@@ -404,6 +416,8 @@ ffmpeg_ram_new_encoder(const char *name, const char *mc_name, int width,
                        int height, int pixfmt, int align, int fps, int gop,
                        int rc, int quality, int kbs, int q, int thread_count,
-                       int gpu, int *linesize, int *offset, int *length,
+                       int gpu, int min_qp, int max_qp, int rc_buffer_size,
+                       int *linesize, int *offset, int *length,
                        RamEncodeCallback callback) {
   std::unique_ptr<FFmpegRamEncoder> encoder(new FFmpegRamEncoder(
       name, mc_name, width, height, pixfmt, align, fps, gop, rc, quality, kbs,
-      q, thread_count, gpu, callback));
+      q, thread_count, gpu, min_qp, max_qp, rc_buffer_size, callback));
   if (!encoder->init(linesize, offset, length)) {
     return nullptr;
diff --git a/cpp/ffmpeg_ram/ffmpeg_ram_ffi.h b/cpp/ffmpeg_ram/ffmpeg_ram_ffi.h
index 1234567..abcdefg 100644
--- a/cpp/ffmpeg_ram/ffmpeg_ram_ffi.h
+++ b/cpp/ffmpeg_ram/ffmpeg_ram_ffi.h
@@ -19,7 +19,8 @@ typedef void (*RamEncodeCallback)(const uint8_t *data, int len, int64_t pts,
 void *ffmpeg_ram_new_encoder(const char *name, const char *mc_name, int width,
                               int height, int pixfmt, int align, int fps,
                               int gop, int rc, int quality, int kbs, int q,
-                              int thread_count, int gpu, int *linesize,
+                              int thread_count, int gpu,
+                              int min_qp, int max_qp, int rc_buffer_size, int *linesize,
                               int *offset, int *length,
                               RamEncodeCallback callback);
 int ffmpeg_ram_encode(void *encoder, const uint8_t *data, int length,
diff --git a/src/ffmpeg_ram/encode.rs b/src/ffmpeg_ram/encode.rs
index 1234567..abcdefg 100644
--- a/src/ffmpeg_ram/encode.rs
+++ b/src/ffmpeg_ram/encode.rs
@@ -36,6 +36,9 @@ pub struct EncodeContext {
     pub kbs: i32,
     pub q: i32,
     pub thread_count: i32,
+    pub min_qp: i32,  // -1 means not set
+    pub max_qp: i32,  // -1 means not set
+    pub rc_buffer_size: i32,  // -1 means auto, otherwise in kbps
 }
 
 pub struct EncodeFrame {
@@ -85,6 +88,9 @@ impl Encoder {
                 ctx.fps,
                 ctx.gop,
                 ctx.rc as _,
                 ctx.quality as _,
                 ctx.kbs,
                 ctx.q,
                 ctx.thread_count,
                 gpu,
+                ctx.min_qp,
+                ctx.max_qp,
+                ctx.rc_buffer_size,
                 linesize.as_mut_ptr(),
                 offset.as_mut_ptr(),
diff --git a/src/ffmpeg_ram/mod.rs b/src/ffmpeg_ram/mod.rs
index 1234567..abcdefg 100644
--- a/src/ffmpeg_ram/mod.rs
+++ b/src/ffmpeg_ram/mod.rs
@@ -36,6 +36,9 @@ extern "C" {
         q: c_int,
         thread_count: c_int,
         gpu: c_int,
+        min_qp: c_int,
+        max_qp: c_int,
+        rc_buffer_size: c_int,
         linesize: *mut c_int,
         offset: *mut c_int,
         length: *mut c_int,
